local ___MODULE___ = {}

local ___TweenService___     = game:GetService('TweenService')
local ___Workspace___        = game:GetService('Workspace')
local ___RunService___       = game:GetService('RunService')

function ___MODULE___.createBasic(_rockAmount_, _minSize_, _maxSize_, _easingStyle_, _startingPosition_, _distanceAway_, _rockDelay_)
	
	local ___STARTINGANGLE___    = 0
	local ___OFFSETBASEPART___   = Instance.new('Part', workspace) ___OFFSETBASEPART___.Anchored = true ___OFFSETBASEPART___.CanCollide = false ___OFFSETBASEPART___.Transparency = 1 ___OFFSETBASEPART___.CFrame = CFrame.new(_startingPosition_)
	local ___MAXDEGREES___       = 360
	local ___SEPARATINGANGLE___  = ___MAXDEGREES___ / _rockAmount_
	
	for i=1, _rockAmount_ do
		
		local ___NEWROCK___ = Instance.new('Part', ___Workspace___)
		___NEWROCK___.Anchored        = true
		___NEWROCK___.CFrame          = (___OFFSETBASEPART___.CFrame * CFrame.Angles(0, math.rad(___STARTINGANGLE___), 0)) * CFrame.new(___OFFSETBASEPART___.CFrame.LookVector * _distanceAway_)
		___STARTINGANGLE___           = ___STARTINGANGLE___ + ___SEPARATINGANGLE___
		
		local ___ROCKSIZE___          = math.random(_minSize_, _maxSize_)
		___NEWROCK___.Size            = Vector3.new(___ROCKSIZE___, ___ROCKSIZE___, ___ROCKSIZE___)
		
		local ___ORIENTATIONX___      = math.random(-360, 360)
		local ___ORIENTATIONY___      = math.random(-360, 360)
		local ___ORIENTATIONZ___      = math.random(-360, 360)
		
		___NEWROCK___.Orientation     = Vector3.new(___ORIENTATIONX___, ___ORIENTATIONY___, ___ORIENTATIONZ___)
		
		local ___RAYCAST___           = Ray.new(___NEWROCK___.Position + Vector3.new(0, 2.5, 0), -Vector3.new(0, 10, 0))
		local ___RESULT___, ___POS___ = ___Workspace___:FindPartOnRayWithIgnoreList(___RAYCAST___, {___NEWROCK___})
		if ___RESULT___ then
			
			___NEWROCK___.Color       = ___RESULT___.Color
			___NEWROCK___.Material    = ___RESULT___.Material
		else
			
			___NEWROCK___:Destroy()
		end
		
		spawn(function()
			
			local ___STARTPOSITION___     = ___NEWROCK___.Position
			___NEWROCK___.Position = ___NEWROCK___.Position + -Vector3.new(0, 5, 0)

			local ___TWEENUPINFO___       = TweenInfo.new(.75, _easingStyle_, Enum.EasingDirection.Out)
			local ___TWEENUP___           = ___TweenService___:Create(___NEWROCK___, ___TWEENUPINFO___, {Position = ___STARTPOSITION___})
			___TWEENUP___:Play()

			repeat task.wait() until ___TWEENUP___.Completed
			task.wait(_rockDelay_)

			local ___ENDPOSITION___         = ___STARTPOSITION___ + -Vector3.new(0, 7.5, 0)
			local ___TWEENDOWNINFO___       = TweenInfo.new(1.25, Enum.EasingStyle.Quad, Enum.EasingDirection.In)
			local ___TWEENDOWN___           = ___TweenService___:Create(___NEWROCK___, ___TWEENDOWNINFO___, {Position = ___ENDPOSITION___})
			___TWEENDOWN___:Play()
			
			delay(1, function()
				
				___NEWROCK___:Destroy()
			end)
		end)
	end
end

function ___MODULE___.createCircular(_cirlceAmount_, _rockAmount_, _rockAdd_, _rockSize_, _easingStyle_, _startingPosition_, _distanceInterval_, _rockInterval_, _rockDelay_)
	
	local ___ROCKAMOUNT___       = _rockAmount_
	local ___STARTINGANGLE___    = 0
	local ___OFFSETBASEPART___   = Instance.new('Part', workspace) ___OFFSETBASEPART___.Anchored = true ___OFFSETBASEPART___.CanCollide = false ___OFFSETBASEPART___.Transparency = 1 ___OFFSETBASEPART___.CFrame = CFrame.new(_startingPosition_)
	local ___MAXDEGREES___       = 360
	local ___DISTANCE___         = _distanceInterval_
	local ___GOAL___             = ___OFFSETBASEPART___.Position + Vector3.new(0, 5, 0)
	
	local function ___SPAWN___()
		
		for i=1, ___ROCKAMOUNT___ do
			local ___SEPARATINGANGLE___  = ___MAXDEGREES___ / ___ROCKAMOUNT___

			local ___NEWROCK___ = Instance.new('Part', ___Workspace___)
			___NEWROCK___.Anchored        = true
			___NEWROCK___.CFrame          = (___OFFSETBASEPART___.CFrame * CFrame.Angles(0, math.rad(___STARTINGANGLE___), 0)) * CFrame.new(___OFFSETBASEPART___.CFrame.LookVector * ___DISTANCE___)
			___NEWROCK___.CFrame          = CFrame.new(___NEWROCK___.Position, Vector3.new(___GOAL___.X, ___GOAL___.Y, ___GOAL___.Z))
			___STARTINGANGLE___           = ___STARTINGANGLE___ + ___SEPARATINGANGLE___

			___NEWROCK___.Size            = Vector3.new(_rockSize_, _rockSize_, _rockSize_)
			
			local ___RAYCAST___           = Ray.new(___NEWROCK___.Position + Vector3.new(0, 2.5, 0), -Vector3.new(0, 10, 0))
			local ___RESULT___, ___POS___ = ___Workspace___:FindPartOnRayWithIgnoreList(___RAYCAST___, {___NEWROCK___})
			if ___RESULT___ then

				___NEWROCK___.Color       = ___RESULT___.Color
				___NEWROCK___.Material    = ___RESULT___.Material
			else

				___NEWROCK___:Destroy()
			end
			
			spawn(function()
				
				local ___STARTPOSITION___     = ___NEWROCK___.Position
				___NEWROCK___.Position = ___NEWROCK___.Position + -Vector3.new(0, 5, 0)

				local ___TWEENUPINFO___       = TweenInfo.new(.75, _easingStyle_, Enum.EasingDirection.Out)
				local ___TWEENUP___           = ___TweenService___:Create(___NEWROCK___, ___TWEENUPINFO___, {Position = ___STARTPOSITION___})
				___TWEENUP___:Play()

				repeat task.wait() until ___TWEENUP___.Completed
				task.wait(_rockDelay_)

				local ___ENDPOSITION___         = ___STARTPOSITION___ + -Vector3.new(0, 7.5, 0)
				local ___TWEENDOWNINFO___       = TweenInfo.new(1, Enum.EasingStyle.Quad, Enum.EasingDirection.In)
				local ___TWEENDOWN___           = ___TweenService___:Create(___NEWROCK___, ___TWEENDOWNINFO___, {Position = ___ENDPOSITION___})
				___TWEENDOWN___:Play()

				delay(_rockDelay_, function()

					___NEWROCK___:Destroy()
				end)
			end)
		end
		
		___DISTANCE___                    = ___DISTANCE___ + _distanceInterval_
		___ROCKAMOUNT___                  = ___ROCKAMOUNT___ + _rockAdd_
	end
	
	for i=1, _cirlceAmount_ do
		
		___SPAWN___()
		task.wait(_rockInterval_)
	end
end

return ___MODULE___
